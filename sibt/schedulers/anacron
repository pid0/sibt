from sibt.infrastructure.coprocessrunner import CoprocessRunner
import os
import tempfile
from contextlib import contextmanager
import functools
import shlex
import subprocess
import re
from datetime import timedelta

availableSharedOptions = ["s AllowedHours", "f TmpDir"]
availableOptions = ["t Interval", "f LogFile", "s ExecOnFailure", "b Syslog"]

CommonFileNamePrefix = "sibt-anacron-"
TabPrefix = CommonFileNamePrefix + "tab-"
ScriptPrefix = CommonFileNamePrefix + "script-"
AllowedHoursRegex = re.compile("([0-9]+)-([0-9]+)")
SecondsInADay = 86400

def quoted(string):
  return shlex.quote(string)

def quotedOpt(options, optionKey):
  string = str(options.get(optionKey, ""))
  return quoted(string)

class Anacron(object):
  def init(self, args):
    self.processRunner = CoprocessRunner()
    self.sibtCall = args.sibtInvocation
    self.varDir = args.varDir
    self.logger = args.logger
    self.spoolDir = os.path.join(self.varDir, "spool")
    if not os.path.isdir(self.spoolDir):
      os.mkdir(self.spoolDir)

  def getIntervalInDays(self, scheduling):
    interval = scheduling.options.get("Interval", timedelta(days=3))
    days = int(interval / timedelta(seconds=1)) / SecondsInADay
    roundedDays = round(days)
    if days != roundedDays:
      self.logger.log("warning: rounding interval of ‘{0}’ to days ({1})",
          scheduling.ruleName, roundedDays)
    return str(int(roundedDays))

  def run(self, schedulings):
    tmpDir = str(schedulings[0].options.get("TmpDir", tempfile.gettempdir()))

    with writeAndCloseTemporaryFile(tmpDir, ScriptPrefix, 
        self.writeScript) as scriptPath:
      with writeAndCloseTemporaryFile(tmpDir, TabPrefix, functools.partial(
          self.writeTabFile, scriptPath, schedulings)) as tabPath:
        self.processRunner.execute("anacron", "-t", tabPath,
            "-S", self.spoolDir, "-d")

  def writeTabFile(self, scriptPath, schedulings, tabFile):
    for scheduling in schedulings:
      if "AllowedHours" in scheduling.options:
        tabFile.write("START_HOURS_RANGE={0}".format(
            scheduling.options["AllowedHours"]) + "\n")
        break

    for scheduling in schedulings:
      self.writeTabEntry(scriptPath, tabFile, scheduling)

  def check(self, schedulings):
    ret = []
    ret.extend(self.checkOptionOfEachScheduling(schedulings, "AllowedHours",
      lambda setting, ruleName: None if self.hasCorrectAllowedHoursSyntax(
        setting) else "Syntax error in AllowedHours setting of ‘{0}’ (‘{1}’)".\
            format(ruleName, setting)))

    ret.extend(self.checkOptionOfEachScheduling(schedulings, "ExecOnFailure",
      self.checkExecOnFailureSyntax))

    return ret

  def checkOptionOfEachScheduling(self, schedulings, optionName, checkFunc):
    ret = []
    for scheduling in schedulings:
      if optionName not in scheduling.options:
        continue
      error = checkFunc(scheduling.options[optionName], 
          scheduling.ruleName)
      if error is not None:
        ret.append(error)
    return ret

  def hasCorrectAllowedHoursSyntax(self, string):
    regexMatch = AllowedHoursRegex.fullmatch(string)
    if regexMatch is None:
      return False
    startHour = int(regexMatch.group(1))
    endHour = int(regexMatch.group(2))
    return startHour < endHour and endHour < 25

  def checkExecOnFailureSyntax(self, code, ruleName):
    with subprocess.Popen(["bash", "-n", "-c", code + " | cat"], 
        stderr=subprocess.PIPE) as process:
      _, stderrBytes = process.communicate()
      process.wait()
    syntaxErrors = stderrBytes.decode()
    if len(syntaxErrors) > 0:
      return "syntax errors in ExecOnFailure code of ‘{0}’:\n{1}".format(
        ruleName, syntaxErrors)

  def writeScript(self, scriptFile):
    scriptFile.write("""#!/usr/bin/env bash
trap '' INT TERM
declare -a sibtProgram=({sibtProg})
ruleName="$1"
logFile="$2"
execOnFailure="$3"
syslog="$4"
syslogTestOpts="$5"
declare -a sibtCall=("${sibtProgram[@]}" sync-uncontrolled -- "$ruleName")

set -o pipefail

logCommand=tee
if [ $syslog = 1 ]; then
  logCommand+=' >(logger -t sibt $syslogTestOpts)'
fi
if [ -n "$logFile" ]; then
  logCommand+=' >(cat >>"$logFile")'
fi

(trap - INT TERM; "${sibtCall[@]}") 2>&1 | eval $logCommand
exitCode=$?

if [ $exitCode != 0 ]; then
  r="$ruleName"
  eval "$execOnFailure" | eval $logCommand
fi
exit $exitCode""".replace("{sibtProg}", " ".join(quoted(word) for word in 
  self.sibtCall)))

  def writeTabEntry(self, scriptPath, tabFile, scheduling):
    for field in [
        self.getIntervalInDays(scheduling),
        "0", 
        scheduling.ruleName,

        "bash",
        quoted(scriptPath),
        scheduling.ruleName,
        quotedOpt(scheduling.options, "LogFile"),
        quotedOpt(scheduling.options, "ExecOnFailure"),
        "1" if scheduling.options.get("Syslog", False) else "0",
        quotedOpt(scheduling.options, "SyslogTestOpts")]:
      tabFile.write(field)
      tabFile.write(" ")

    tabFile.write("\n")

  def findFileName(self, folder, prefix):
    counter = 1
    ret = None
    while ret is None or os.path.isfile(ret):
      ret = os.path.join(folder, prefix + "-" + str(counter))
      counter += 1
    return ret

@contextmanager
def writeAndCloseTemporaryFile(tmpDir, prefix, writeFunc):
  fd, name = tempfile.mkstemp(dir=tmpDir, prefix=prefix)
  try:
    path = os.path.join(tmpDir, name)
    with os.fdopen(fd, "w+") as tmpFile:
      writeFunc(tmpFile)

    yield path
  finally:
    os.unlink(path)

impl = Anacron()

def init(*args):
  global impl
  impl.init(*args)
def run(*args):
  global impl
  impl.run(*args)
def check(*args):
  global impl
  return impl.check(*args)

