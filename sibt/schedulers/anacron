from sibt.infrastructure.coprocessrunner import CoprocessRunner
from sibt.infrastructure.intervalparser import IntervalParser
import os
from sibt.infrastructure.schedulerhelper import evalTruth

availableOptions = ["Interval", "LogFile", "ExecOnFailure", "AllowedHours",
    "Syslog"]

def quoted(options, optionKey):
  string = options.get(optionKey, "")
  return "'{0}'".format(string)

class Anacron(object):
  def init(self, initSibtCall, paths):
    self.processRunner = CoprocessRunner()
    self.intervalParser = IntervalParser()
    self.sibtCall = initSibtCall
    self.varDir = os.path.join(paths.varDir, "anacron")
    self.spoolDir = os.path.join(self.varDir, "spool")
    if not os.path.isdir(self.spoolDir):
      os.makedirs(self.spoolDir)

  def getInterval(self, scheduling):
    return str(self.intervalParser.parseNumberOfDays(scheduling.options.get(
        "Interval", "3")))

  def run(self, schedulings):
    tabPath = self.findFileName("tab")
    scriptPath = self.findFileName("script")
    self.writeScript(scriptPath)

    with open(tabPath, "w") as tabFile:
      for scheduling in schedulings:
        if "AllowedHours" in scheduling.options:
          tabFile.write("START_HOURS_RANGE={0}".format(
              scheduling.options["AllowedHours"]) + "\n")
          break

      for scheduling in schedulings:
        self.writeTabEntry(scriptPath, tabFile, scheduling)

    self.processRunner.execute("anacron", "-t", tabPath,
        "-S", self.spoolDir, "-d")

    os.remove(tabPath)
    os.remove(scriptPath)

  def check(self, schedulings):
    for scheduling in schedulings:
      try:
        self.getInterval(scheduling)
      except Exception as ex:
        return [str(ex)]

      for option in availableOptions:
        if "'" in scheduling.options.get(option, ""):
          return ["single quote not allowed in {0}".format(option)]

    allowedHours = None
    allowedHoursSettings = [scheduling.options["AllowedHours"] for 
        scheduling in schedulings if "AllowedHours" in scheduling.options]
    if len(allowedHoursSettings) != 0 and not all(setting == 
        allowedHoursSettings[0] for setting in allowedHoursSettings):
      return ["contradictory AllowedHours setting"]

    return []

  def writeScript(self, path):
    with open(path, "w") as scriptFile:
      scriptFile.write("""#!/usr/bin/env bash
declare -a sibtProgram=({sibtProg})
ruleName="$1"
logFile="$2"
execOnFailure="$3"
execOnFailure=${execOnFailure/'%r'/"$ruleName"}
syslog=$4
syslogTestOpts="$5"

set -o pipefail

logCommand=tee
if [ $syslog = 1 ]; then
  logCommand+=' >(logger -t sibt $syslogTestOpts)'
fi
if [ -n "$logFile" ]; then
  logCommand+=' >>"$logFile"'
fi

declare -a sibtCall=("${sibtProgram[@]}" sync-uncontrolled "$ruleName")
if [[ $syslog = 1 || -n "$logFile" ]]; then
  "${sibtCall[@]}" 2>&1 | eval $logCommand
else
  "${sibtCall[@]}"
fi

if [ $? != 0 ]; then
  $execOnFailure
fi
      """.replace("{sibtProg}", " ".join(
          ("'" + word + "'" for word in self.sibtCall))))
    os.chmod(path, 0o700)

  def writeTabEntry(self, scriptPath, tabFile, scheduling):
    for field in [
        self.getInterval(scheduling),
        "0", 
        scheduling.ruleName,

        scriptPath,
        scheduling.ruleName,
        quoted(scheduling.options, "LogFile"),
        quoted(scheduling.options, "ExecOnFailure"),
        "1" if evalTruth(scheduling.options.get("Syslog", "")) else "0",
        quoted(scheduling.options, "SyslogTestOpts")]:
      tabFile.write(field)
      tabFile.write(" ")

    tabFile.write("\n")

  def findFileName(self, prefix):
    counter = 1
    ret = None
    while ret is None or os.path.isfile(ret):
      ret = os.path.join(self.varDir, prefix + "-" + str(counter))
      counter += 1
    return ret

impl = Anacron()

def init(*args):
  global impl
  impl.init(*args)
def run(*args):
  global impl
  impl.run(*args)
def check(*args):
  global impl
  return impl.check(*args)

