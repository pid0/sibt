from sibt.infrastructure.coprocessrunner import CoprocessRunner
from sibt.infrastructure.intervalparser import IntervalParser
import os
from sibt.infrastructure.schedulerhelper import evalTruth
import tempfile
from contextlib import contextmanager
import functools

availableOptions = ["Interval", "LogFile", "ExecOnFailure", "AllowedHours",
    "Syslog", "TmpDir"]

CommonFileNamePrefix = "sibt-anacron-"
TabPrefix = CommonFileNamePrefix + "tab-"
ScriptPrefix = CommonFileNamePrefix + "script-"

def quoted(options, optionKey):
  string = options.get(optionKey, "")
  return "'{0}'".format(string)

class Anacron(object):
  def init(self, initSibtCall, paths):
    self.processRunner = CoprocessRunner()
    self.intervalParser = IntervalParser()
    self.sibtCall = initSibtCall
    self.varDir = os.path.join(paths.varDir, "anacron")
    self.spoolDir = os.path.join(self.varDir, "spool")
    if not os.path.isdir(self.spoolDir):
      os.makedirs(self.spoolDir)

  def getInterval(self, scheduling):
    return str(self.intervalParser.parseNumberOfDays(scheduling.options.get(
        "Interval", "3")))

  def run(self, schedulings):
    tmpDir = schedulings[0].options["TmpDir"] if \
        "TmpDir" in schedulings[0].options else tempfile.gettempdir()

    with writeAndCloseTemporaryFile(tmpDir, ScriptPrefix, 
        self.writeScript) as scriptPath:
      with writeAndCloseTemporaryFile(tmpDir, TabPrefix, functools.partial(
          self.writeTabFile, scriptPath, schedulings)) as tabPath:
        self.processRunner.execute("anacron", "-t", tabPath,
            "-S", self.spoolDir, "-d")

  def writeTabFile(self, scriptPath, schedulings, tabFile):
    for scheduling in schedulings:
      if "AllowedHours" in scheduling.options:
        tabFile.write("START_HOURS_RANGE={0}".format(
            scheduling.options["AllowedHours"]) + "\n")
        break

    for scheduling in schedulings:
      self.writeTabEntry(scriptPath, tabFile, scheduling)

  def check(self, schedulings):
    for scheduling in schedulings:
      try:
        self.getInterval(scheduling)
      #TODO catch this exception more specifically (ParseException...)
      except Exception as ex:
        return [str(ex)]

      for option in availableOptions:
        if "'" in scheduling.options.get(option, ""):
          return ["single quote not allowed in {0}".format(option)]

    allowedHours = None
    allowedHoursSettings = [scheduling.options["AllowedHours"] for 
        scheduling in schedulings if "AllowedHours" in scheduling.options]
    if len(allowedHoursSettings) != 0 and not all(setting == 
        allowedHoursSettings[0] for setting in allowedHoursSettings):
      return ["contradictory AllowedHours setting"]

    return []

  def writeScript(self, scriptFile):
    scriptFile.write("""#!/usr/bin/env bash
trap '' INT TERM
declare -a sibtProgram=({sibtProg})
ruleName="$1"
logFile="$2"
execOnFailure="$3"
execOnFailure=${execOnFailure/'%r'/"$ruleName"}
syslog="$4"
syslogTestOpts="$5"

set -o pipefail

logCommand=tee
if [ $syslog = 1 ]; then
  logCommand+=' >(logger -t sibt $syslogTestOpts)'
fi
if [ -n "$logFile" ]; then
  logCommand+=' >>"$logFile"'
fi

declare -a sibtCall=("${sibtProgram[@]}" sync-uncontrolled -- "$ruleName")
if [[ $syslog = 1 || -n "$logFile" ]]; then
  (trap - INT TERM; "${sibtCall[@]}") 2>&1 | eval $logCommand
else
  (trap - INT TERM; "${sibtCall[@]}")
fi

if [ $? != 0 ]; then
  $execOnFailure
fi""".replace("{sibtProg}", " ".join("'" + word + "'" for word in 
  self.sibtCall)))

  def writeTabEntry(self, scriptPath, tabFile, scheduling):
    for field in [
        self.getInterval(scheduling),
        "0", 
        scheduling.ruleName,

        "bash",
        scriptPath,
        scheduling.ruleName,
        quoted(scheduling.options, "LogFile"),
        quoted(scheduling.options, "ExecOnFailure"),
        "1" if evalTruth(scheduling.options.get("Syslog", "")) else "1",
        quoted(scheduling.options, "SyslogTestOpts")]:
      tabFile.write(field)
      tabFile.write(" ")

    tabFile.write("\n")

  def findFileName(self, folder, prefix):
    counter = 1
    ret = None
    while ret is None or os.path.isfile(ret):
      ret = os.path.join(folder, prefix + "-" + str(counter))
      counter += 1
    return ret

@contextmanager
def writeAndCloseTemporaryFile(tmpDir, prefix, writeFunc):
  fd, name = tempfile.mkstemp(dir=tmpDir, prefix=prefix)
  try:
    path = os.path.join(tmpDir, name)
    with os.fdopen(fd, "w+") as tmpFile:
      writeFunc(tmpFile)

    yield path
  finally:
    os.unlink(path)

impl = Anacron()

def init(*args):
  global impl
  impl.init(*args)
def run(*args):
  global impl
  impl.run(*args)
def check(*args):
  global impl
  return impl.check(*args)

