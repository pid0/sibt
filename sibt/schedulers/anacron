from sibt.infrastructure.coprocessrunner import CoprocessRunner
from sibt.infrastructure.schedulerhelper import checkOptionOfEachScheduling
import os
import tempfile
from contextlib import contextmanager
import functools
import shlex
import subprocess
import re
from datetime import timedelta, datetime, timezone

availableSharedOptions = ["s AllowedHours", "f TmpDir"]
availableOptions = ["t Interval"]

CommonFileNamePrefix = "sibt-anacron-"
TabPrefix = CommonFileNamePrefix + "tab-"
AllowedHoursRegex = re.compile("([0-9]+)-([0-9]+)")
SecondsInADay = 86400

def quoted(string):
  return shlex.quote(string)

def quotedOpt(options, optionKey):
  string = str(options.get(optionKey, ""))
  return quoted(string)

class Anacron(object):
  def init(self, args):
    self.processRunner = CoprocessRunner()
    self.sibtCall = args.sibtInvocation
    self.varDir = args.varDir
    self.logger = args.logger
    self.spoolDir = os.path.join(self.varDir, "spool")
    if not os.path.isdir(self.spoolDir):
      os.mkdir(self.spoolDir)

  def getIntervalInDays(self, scheduling, warn=False):
    interval = scheduling.options.get("Interval", timedelta(days=3))
    days = int(interval / timedelta(seconds=1)) / SecondsInADay
    roundedDays = round(days)
    if days != roundedDays and warn:
      self.logger.log("warning: rounding interval of ‘{0}’ to days ({1})",
          scheduling.ruleName, roundedDays)
    return int(roundedDays)

  def run(self, schedulings):
    tmpDir = str(schedulings[0].options.get("TmpDir", tempfile.gettempdir()))

    with writeAndCloseTemporaryFile(tmpDir, TabPrefix, functools.partial(
        self.writeTabFile, schedulings)) as tabPath:
      self.processRunner.execute("anacron", "-t", tabPath,
          "-S", self.spoolDir, "-d")

  def writeTabFile(self, schedulings, tabFile):
    for scheduling in schedulings:
      if "AllowedHours" in scheduling.options:
        tabFile.write("START_HOURS_RANGE={0}".format(
            scheduling.options["AllowedHours"]) + "\n")
        break

    for scheduling in schedulings:
      self.writeTabEntry(tabFile, scheduling)

  def check(self, schedulings):
    ret = []
    ret.extend(checkOptionOfEachScheduling(schedulings, "AllowedHours",
      lambda _, setting, ruleName: None if self.hasCorrectAllowedHoursSyntax(
        setting) else "Syntax error in AllowedHours setting of ‘{0}’ (‘{1}’)".\
            format(ruleName, setting)))

    for scheduling in schedulings:
      self.getIntervalInDays(scheduling, warn=True)

    return ret

  def hasCorrectAllowedHoursSyntax(self, string):
    regexMatch = AllowedHoursRegex.fullmatch(string)
    if regexMatch is None:
      return False
    startHour = int(regexMatch.group(1))
    endHour = int(regexMatch.group(2))
    return startHour < endHour and endHour < 25

  def writeTabEntry(self, tabFile, scheduling):
    fields = [
        str(self.getIntervalInDays(scheduling, warn=True)),
        "0", 
        scheduling.ruleName]
    fields += [quoted(word) for word in self.sibtCall]
    fields += ["execute-rule", "--", quoted(scheduling.ruleName)]

    for field in fields:
      tabFile.write(field)
      tabFile.write(" ")

    tabFile.write("\n")

  def nextExecutionTime(self, scheduling, lastTime):
    if lastTime is None:
      return datetime.now(timezone.utc)

    interval = timedelta(days=self.getIntervalInDays(scheduling))
    exactTime = lastTime + interval
    return datetime(exactTime.year, exactTime.month, exactTime.day, 0, 0, 0, 0,
        exactTime.tzinfo)

@contextmanager
def writeAndCloseTemporaryFile(tmpDir, prefix, writeFunc):
  fd, name = tempfile.mkstemp(dir=tmpDir, prefix=prefix)
  try:
    path = os.path.join(tmpDir, name)
    with os.fdopen(fd, "w+") as tmpFile:
      writeFunc(tmpFile)

    yield path
  finally:
    os.unlink(path)

impl = Anacron()

def init(*args):
  global impl
  impl.init(*args)
def run(*args):
  global impl
  impl.run(*args)
def check(*args):
  global impl
  return impl.check(*args)
def nextExecutionTime(*args):
  global impl
  return impl.nextExecutionTime(*args)
